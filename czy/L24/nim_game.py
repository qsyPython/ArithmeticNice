# 你和你的朋友，两个人一起玩 Nim游戏：桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。你作为先手。
#
# 你们是聪明人，每一步都是最优解。 编写一个函数，来判断你是否可以在给定石头数量的情况下赢得游戏。
#
# 示例:
#
# 输入: 4
# 输出: false
# 解释: 如果堆中有 4 块石头，那么你永远不会赢得比赛；
#      因为无论你拿走 1 块、2 块 还是 3 块石头，最后一块石头总是会被你的朋友拿走。

# 思路：
# 这里做一个抽象，假设一推里面有n个石头，每次可以取
# 1 - m
# 个石头。
#
# 显然，如果n = m + 1，那么由于一次最多只能取m个，所以，无论先取者拿走多少个，后取者都能够一次拿走剩余的物品，后者取胜。这里我们就有一个想法了，假设这个石头推为(m + 1)
# 的倍数，那么第一个人取k(1 <= k <= m)
# 个，只要第二个人取(m + 1 - k)
# 个石头，那么必定状态能回到最初的状态，m + 1
# 个。因为每个人都是很聪明的，取的石头的个数一定要对自己有利。那么，假设最初石头推不为(m + 1)
# 的倍数。n =（m + 1）r + s，那么第一个人只要取s个石头必定能获得胜利，反之，如果s == 0 ，那么第一个人必输。
#
#
#
# 即，若n = k * (m + 1)，则后取着胜，反之，存在先取者获胜的取法。n % (m + 1) == 0.
# 先取者必败。


def canWinNim(n):

    if n % 4 == 0:
        return False
    else:
        return True

if __name__ == '__main__':

    print(canWinNim(5))
